"""
file:   plot_2d_matplotlib.py
brief:  Python script to visualise transverse intensity profiles of vortex beams. 
        The program extracts 2d slices (for any given section) of an HDF5 file generated by the FDTD solver Meep.
author: Daniel Kotik
date:   18.01.2018
"""
from __future__ import division
import matplotlib.pyplot as plt
import numpy as np
import h5py

#---------------------------------------------------------------------------------------------------
# set parameters
#---------------------------------------------------------------------------------------------------
n       = 1.54 / 1.0           # relative index of refraction
chi_deg = 45.0                 # angle of incidence in degrees
inc_deg = 90 - chi_deg         # inclination of the interface with respect to the x-axis
cutoff  = 30                   # cut off borders of data (remove PML layer up to and including line source placement)

#---------------------------------------------------------------------------------------------------
# import data from HDF file(s)
#---------------------------------------------------------------------------------------------------
path = "simulations/DK_meep-01.03.2018 11_08_44/LaguerreGauss3d_C-out/"
filename_real = path + "e_real2_s-000001540.h5"
filename_imag = path + "e_imag2_s-000001540.h5"

with h5py.File(filename_real, 'r') as hf:
    #print("keys: %s" % hf.keys())
    data_real = hf['e_real2_s'][:]

with h5py.File(filename_imag, 'r') as hf:
    #print("keys: %s" % hf.keys())
    data_imag = hf['e_imag2_s'][:]

data = data_real + data_imag
del data_imag                                       # free memory early

orig_shape = np.shape(data)

print "file size in MB: ", data.nbytes / 1024 / 1024
print "data (max, min): ", (data.max(), data.min())
print "original shape:  ", orig_shape

data = data[cutoff:-cutoff, cutoff:-cutoff, cutoff:-cutoff] / data.max()
new_shape = np.shape(data)

center_index = np.int(data.shape[2]/2)
data_poi = data[:,:,center_index]                   # slice within the plane of incidence
print(new_shape)


#------------------------------------------------------------------------------------------------------------------
# calculating central k-vector components
#------------------------------------------------------------------------------------------------------------------
eta_rad = np.arcsin((1.0/n) * np.sin(np.deg2rad(chi_deg)))   # angle of refraction in radians

## properties of the k-vectors
vec_length = 150

## (x,y)-components of the k-vectors (in pixel coordinates)
center = (int((new_shape[0] - 1)/2), int((new_shape[1] - 1)/2))
print center
inc = (-vec_length, 0, 0)
ref = (center[0] + int(np.rint(vec_length * np.sin(np.deg2rad(chi_deg - inc_deg)))),  
       center[1] + int(np.rint(vec_length * np.cos(np.deg2rad(chi_deg - inc_deg)))))
tra = (center[0] + int(np.rint(vec_length * np.sin(eta_rad + np.deg2rad(inc_deg)))), 
       center[1] - int(np.rint(vec_length * np.cos(eta_rad + np.deg2rad(inc_deg)))))
print ref

#-------------------------------------------
# define the position of the line 
x0, y0 = center      # these are in pixel coordinates
x1, y1 = ref
length = int(np.hypot(x1-x0, y1-y0))
x, y = np.linspace(x0, x1, length, dtype=np.int), np.linspace(y0, y1, length, dtype=np.int)

trans_slice_inc = data[x, y, :]
print np.shape(trans_slice_inc)



#------------------------------------------------------------------------------------------------------------------
# visualising 
#------------------------------------------------------------------------------------------------------------------
fig, (ax1, ax2) = plt.subplots(1, 2)

## visualise intensity dirstribution within the plane of incidence
ax1.imshow(np.transpose(data_poi), origin="lower", cmap=plt.cm.hot, interpolation='None')
ax1.plot([x0, x1], [y0, y1], 'ro-')
ax1.set_xlabel('x')                                 # labels are according to Meep
ax1.set_ylabel('y')


## visualise transverse intensity distribution with respect to the axes of the central wave vectors
ax2.imshow(np.transpose(trans_slice_inc), origin="lower", cmap=plt.cm.hot, interpolation='None')
ax2.set_xlabel('x')                                 # labels are according to Meep
ax2.set_ylabel('z')
#plt.colorbar()
plt.show()

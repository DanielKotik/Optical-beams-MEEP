"""
file:   plot_3d_mayavi.py
brief:  Python script to visualise (intensity) isosurfaces of scattered vortex beams.
        The program uses as input HDF5 files generated by the FDTD solver Meep.
author: Daniel Kotik
date:   19.01.2018
"""
from __future__ import division
from mayavi     import mlab
from tvtk.util  import ctf            # color transfer function

import numpy as np
import h5py


def cuboid(ext_grid, rot=0, color=(1,0,0), opacity=1.0):
    """Returns a cuboid defined on the grid 'ext_grid' with an angle of rotation 'rot' about the z-axis given in 
       degrees. This cuboid is ment to represent the optically denser material.
    """
    xl, xr, yl, yr, zl, zr = ext_grid
    
    triangles = [(0,1,2), (1,2,3), (0,1,4), (1,4,5), (4,5,6), (6,7,5),
                 (2,3,6), (3,6,7), (0,2,6), (0,6,4), (3,1,7), (1,7,5)]
    
    x = np.tile(np.array([xr,xr,xl,xl]), 2)   # repeat array twice
    y = np.tile(np.array([yl,yr,yl,yr]), 2)   # repeat array twice
    z = np.concatenate((np.array([zl,zl,zl,zl]), np.array([zr,zr,zr,zr])))
    
    rot = np.deg2rad(rot)
    
    xr = np.cos(rot)*x - np.sin(rot)*y
    yr = np.sin(rot)*x + np.cos(rot)*y
    
    return mlab.triangular_mesh(xr, yr, z, triangles, color=color, opacity=opacity)


#---------------------------------------------------------------------------------------------------
# set parameters
#---------------------------------------------------------------------------------------------------
n       = 1.54 / 1.0           # relative index of refraction
chi_deg = 45.0                 # angle of incidence in degrees
inc_deg = 90 - chi_deg         # inclination of the interface with respect to the x-axis
cutoff  = 30                   # cut off borders of data (remove PML layer up to and including line source placement)


#---------------------------------------------------------------------------------------------------
# import data from HDF file(s)
#---------------------------------------------------------------------------------------------------
path = "simulations/DK_meep-01.03.2018 11_08_44/LaguerreGauss3d_C-out/"
filename_real = path + "e_real2_s-000001540.h5"
filename_imag = path + "e_imag2_s-000001540.h5"

with h5py.File(filename_real, 'r') as hf:
    #print("keys: %s" % hf.keys())
    data_real = hf['e_real2_s'][:]

with h5py.File(filename_imag, 'r') as hf:
    #print("keys: %s" % hf.keys())
    data_imag = hf['e_imag2_s'][:]

## choose wheather to use the electric field energy density (proportional to 'data_real') or the complex modulus of the
## complex electric field (proportional to 'data_real + data_imag') as data basis:
data = data_real
#data = data_real + data_imag

try:
    del data_imag                                       # free memory early
except:
    pass
    
orig_shape = np.shape(data)

print "file size in MB: ", data.nbytes / 1024 / 1024
print "data (max, min): ", (data.max(), data.min())
print "original shape:  ", orig_shape

data = data[cutoff:-cutoff, cutoff:-cutoff, cutoff:-cutoff] / data.max()
new_shape = np.shape(data)


#------------------------------------------------------------------------------------------------------------------
# visualising an iso-contour surface of the vortex beam
#------------------------------------------------------------------------------------------------------------------
fig = mlab.figure(1, bgcolor=(0, 0, 0), size=(400, 400))
fig.scene.render_window.aa_frames = 8               # antialiasing

sx, sy, sz = np.array([5, 5, 3.5]) * np.asarray(new_shape) / np.asarray(orig_shape)
SX, SY, SZ = np.mgrid[-sx/2.0:sx/2.0:eval('{}j'.format(data.shape[0])),
                      -sy/2.0:sy/2.0:eval('{}j'.format(data.shape[1])),
                      -sz/2.0:sz/2.0:eval('{}j'.format(data.shape[2]))]

src = mlab.pipeline.scalar_field(SX, SY, SZ, data)  # Mayavi source
del data, SX, SY, SZ                                # free memory early


voi = mlab.pipeline.extract_grid(src)               # volume of interest
voi.set(z_max=np.ceil(new_shape[2]/2))              # halving volume at plane of incidence (comment out to visualise
                                                    # entire beam)

VMAX = 0.02
iso = mlab.pipeline.iso_surface(voi, colormap="hot", contours=[VMAX])
iso.module_manager.scalar_lut_manager.use_default_range = False 
iso.module_manager.scalar_lut_manager.data_range = [0.0, VMAX]

## add two cut planes to show the transverse intensity distributions
pipe_inc = mlab.pipeline.image_plane_widget(src, plane_orientation='x_axes', slice_index=0, colormap='hot', 
                                                 vmin=0.0, vmax=VMAX)
pipe_ref = mlab.pipeline.image_plane_widget(src, plane_orientation='y_axes', slice_index=new_shape[1], colormap='hot', 
                                                 vmin=0.0, vmax=VMAX)


#------------------------------------------------------------------------------------------------------------------
# visualising k-vectors of central plane waves according to classical geometric optics
#------------------------------------------------------------------------------------------------------------------
eta_rad = np.arcsin((1.0/n) * np.sin(np.deg2rad(chi_deg)))   # angle of refraction in radians

## properties of the k-vectors
vec_length = 3.5
vec_radius = 0.008
vec_color  = (1,0,0)

## components of the k-vectors
inc = (-vec_length, 0, 0)
ref = ( vec_length * np.sin(np.deg2rad(chi_deg - inc_deg)),  vec_length * np.cos(np.deg2rad(chi_deg - inc_deg)), 0)
tra = ( vec_length * np.sin(eta_rad + np.deg2rad(inc_deg)), -vec_length * np.cos(eta_rad + np.deg2rad(inc_deg)), 0)

components = [inc, ref, tra]

## visualise incident beam
vector = mlab.quiver3d(0,0,0,*components[0], color=vec_color, scale_factor=1, mode='cylinder',resolution=25)
vector.glyph.glyph_source.glyph_source.radius = vec_radius

## visualise secondary beams
for i in [1,2]:
    vectors = mlab.quiver3d(0,0,0,*components[i], color=vec_color, scale_factor=1, mode='arrow',resolution=25)
    vectors.glyph.glyph_source.glyph_source.shaft_radius = vec_radius
    vectors.glyph.glyph_source.glyph_source.tip_radius   = 0.025
    vectors.glyph.glyph_source.glyph_source.tip_length   = 0.13


#vol = mlab.pipeline.volume(src) #, vmin=0.005, vmax=0.123)

## Changing colormap for a vtk volume render:
# ------------------- old variant ------------------------------------------------
'''
# Changing the ctf:
from tvtk.util.ctf import ColorTransferFunction
ctf = ColorTransferFunction()
# Add points to CTF
ctf.add_rgb_point(0.05, 0, 0, 0) # black
ctf.add_rgb_point(1.55/2, 255, 0, 0) # red
ctf.add_rgb_point(1.5, 255, 255, 255) #white
# Update CTF
vol._volume_property.set_color(ctf)
vol._ctf = ctf
vol.update_ctf = True
'''

# ------------------- new variant ------------------------------------------------
'''# save the existing colormap
c = ctf.save_ctfs(vol._volume_property)
# change it with the colors of the new colormap
values = np.linspace(VMIN, VMAX, 256)
A = plt.cm.get_cmap('hot')(values.copy())
i = np.argsort([2, 3, 4, 1])
A = A[:,i]
A[:,0] = values
c['rgb'] = A
# change the alpha channel as needed
c['alpha'][1][1] = 0.04
#load the color transfer function to the volume
ctf.load_ctfs(c, vol._volume_property)
#signal for update
vol.update_ctf = True'''


color_overlay = (0.227, 0.188, 0.188)
cuboid(ext_grid=(-sx/2.0,sx/2.0, -sy/1.5, 0, -sz/2.0, sz/2.0), rot=inc_deg, color=color_overlay, opacity=0.5)


#mlab.orientation_axes()
mlab.view(azimuth=-inc_deg, elevation=0, distance=12, focalpoint='auto')
fig.scene.camera.azimuth(20)
fig.scene.camera.elevation(30)

#mlab.savefig('visualize_field.png')
mlab.show()

## free memory
try:
    del src, vol, voi, pipe_inc, pipe_ref, iso, SX, SY, SZ
except:
    pass
